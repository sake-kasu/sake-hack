// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// APIError defines model for APIError.
type APIError struct {
	// Code エラーコード
	Code string `json:"code"`

	// Message エラーメッセージ
	Message string `json:"message"`
}

// Brewery defines model for Brewery.
type Brewery struct {
	// Id 酒造ID
	Id int32 `json:"id"`

	// Latitude 緯度
	Latitude *float64 `json:"latitude"`

	// Longitude 経度
	Longitude *float64 `json:"longitude"`

	// Name 酒造名
	Name string `json:"name"`

	// OriginCountry 所在国
	OriginCountry string `json:"originCountry"`

	// OriginRegion 所在地域
	OriginRegion *string `json:"originRegion"`
}

// DrinkStyle defines model for DrinkStyle.
type DrinkStyle struct {
	// Description 詳細説明
	Description *string `json:"description"`

	// Id 飲み方ID
	Id int32 `json:"id"`

	// Name 飲み方の名前
	Name string `json:"name"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Data レスポンスデータ
	Data *map[string]interface{} `json:"data"`

	// Errors エラー情報の配列
	Errors *[]APIError `json:"errors,omitempty"`
}

// ListSakesResponse defines model for ListSakesResponse.
type ListSakesResponse struct {
	// Data 酒のリスト
	Data   *[]Sake       `json:"data,omitempty"`
	Errors *[]APIError   `json:"errors,omitempty"`
	Meta   *SakeListMeta `json:"meta,omitempty"`
}

// PaginationMeta defines model for PaginationMeta.
type PaginationMeta struct {
	// Page 現在のページ番号
	Page int32 `json:"page"`

	// PerPage 1ページあたりの件数
	PerPage int32 `json:"perPage"`

	// Total 総件数
	Total int64 `json:"total"`

	// TotalPages 総ページ数
	TotalPages int32 `json:"totalPages"`
}

// Sake defines model for Sake.
type Sake struct {
	// Abv アルコール度数(%)
	Abv     float32 `json:"abv"`
	Brewery Brewery `json:"brewery"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"createdAt"`

	// DrinkStyles おすすめの飲み方
	DrinkStyles []DrinkStyle `json:"drinkStyles"`

	// Id 酒ID
	Id int32 `json:"id"`

	// Memo 感想
	Memo *string `json:"memo"`

	// Name 酒名
	Name string `json:"name"`

	// TasteNotes 味の特徴
	TasteNotes string   `json:"tasteNotes"`
	Type       SakeType `json:"type"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updatedAt"`
}

// SakeListMeta defines model for SakeListMeta.
type SakeListMeta struct {
	// Limit 取得した件数
	Limit int32 `json:"limit"`

	// Offset スキップした件数
	Offset int32 `json:"offset"`

	// Total 総件数
	Total int64 `json:"total"`
}

// SakeType defines model for SakeType.
type SakeType struct {
	// Id 酒の種類ID
	Id int32 `json:"id"`

	// Name 酒の種類の名前
	Name string `json:"name"`
}

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// Conflict defines model for Conflict.
type Conflict = ErrorResponse

// Forbidden defines model for Forbidden.
type Forbidden = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorResponse

// ListSakesParams defines parameters for ListSakes.
type ListSakesParams struct {
	// Offset スキップする件数
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit 取得する件数
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// TypeId 酒の種類IDでフィルタ
	TypeId *int32 `form:"typeId,omitempty" json:"typeId,omitempty"`

	// BreweryId 酒造IDでフィルタ
	BreweryId *int32 `form:"breweryId,omitempty" json:"breweryId,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 酒一覧取得
	// (GET /sakes)
	ListSakes(c *gin.Context, params ListSakesParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListSakes operation middleware
func (siw *ServerInterfaceWrapper) ListSakes(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSakesParams

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "typeId" -------------

	err = runtime.BindQueryParameter("form", true, false, "typeId", c.Request.URL.Query(), &params.TypeId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter typeId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "breweryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "breweryId", c.Request.URL.Query(), &params.BreweryId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter breweryId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListSakes(c, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/sakes", wrapper.ListSakes)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAAA///vqmxF0hgAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
