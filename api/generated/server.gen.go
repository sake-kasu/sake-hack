// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// APIError defines model for APIError.
type APIError struct {
	// Code エラーコード
	Code string `json:"code"`

	// Message エラーメッセージ
	Message string `json:"message"`
}

// Brewery defines model for Brewery.
type Brewery struct {
	// Id 酒造ID
	Id int32 `json:"id"`

	// Latitude 緯度
	Latitude *float64 `json:"latitude"`

	// Longitude 経度
	Longitude *float64 `json:"longitude"`

	// Name 酒造名
	Name string `json:"name"`

	// OriginCountry 所在国
	OriginCountry string `json:"origin_country"`

	// OriginRegion 所在地域
	OriginRegion *string `json:"origin_region"`
}

// DrinkStyle defines model for DrinkStyle.
type DrinkStyle struct {
	// Description 詳細説明
	Description *string `json:"description"`

	// Id 飲み方ID
	Id int32 `json:"id"`

	// Name 飲み方の名前
	Name string `json:"name"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Data レスポンスデータ
	Data *map[string]interface{} `json:"data"`

	// Errors エラー情報の配列
	Errors *[]APIError `json:"errors,omitempty"`
}

// ListSakesResponse defines model for ListSakesResponse.
type ListSakesResponse struct {
	// Data 酒のリスト
	Data   *[]Sake       `json:"data,omitempty"`
	Errors *[]APIError   `json:"errors,omitempty"`
	Meta   *SakeListMeta `json:"meta,omitempty"`
}

// PaginationMeta defines model for PaginationMeta.
type PaginationMeta struct {
	// Page 現在のページ番号
	Page int32 `json:"page"`

	// PerPage 1ページあたりの件数
	PerPage int32 `json:"per_page"`

	// Total 総件数
	Total int64 `json:"total"`

	// TotalPages 総ページ数
	TotalPages int32 `json:"total_pages"`
}

// Sake defines model for Sake.
type Sake struct {
	// Abv アルコール度数(%)
	Abv     float32 `json:"abv"`
	Brewery Brewery `json:"brewery"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"created_at"`

	// DrinkStyles おすすめの飲み方
	DrinkStyles []DrinkStyle `json:"drink_styles"`

	// Id 酒ID
	Id int32 `json:"id"`

	// Memo 感想
	Memo *string `json:"memo"`

	// Name 酒名
	Name string `json:"name"`

	// TasteNotes 味の特徴
	TasteNotes string   `json:"taste_notes"`
	Type       SakeType `json:"type"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"updated_at"`
}

// SakeListMeta defines model for SakeListMeta.
type SakeListMeta struct {
	// Limit 取得した件数
	Limit int32 `json:"limit"`

	// Offset スキップした件数
	Offset int32 `json:"offset"`

	// Total 総件数
	Total int64 `json:"total"`
}

// SakeType defines model for SakeType.
type SakeType struct {
	// Id 酒の種類ID
	Id int32 `json:"id"`

	// Name 酒の種類の名前
	Name string `json:"name"`
}

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// Conflict defines model for Conflict.
type Conflict = ErrorResponse

// Forbidden defines model for Forbidden.
type Forbidden = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ErrorResponse

// ListSakesParams defines parameters for ListSakes.
type ListSakesParams struct {
	// Offset スキップする件数
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit 取得する件数
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// TypeId 酒の種類IDでフィルタ
	TypeId *int32 `form:"type_id,omitempty" json:"type_id,omitempty"`

	// BreweryId 酒造IDでフィルタ
	BreweryId *int32 `form:"brewery_id,omitempty" json:"brewery_id,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 酒一覧取得
	// (GET /sakes)
	ListSakes(c *gin.Context, params ListSakesParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListSakes operation middleware
func (siw *ServerInterfaceWrapper) ListSakes(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSakesParams

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "type_id", c.Request.URL.Query(), &params.TypeId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter type_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "brewery_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "brewery_id", c.Request.URL.Query(), &params.BreweryId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter brewery_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListSakes(c, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/sakes", wrapper.ListSakes)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"PhGU4vXirwEAAP//Z8VIOuMYAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
