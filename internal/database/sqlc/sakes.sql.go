// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sakes.sql

package sqlc

import (
	"context"
)

const countSakes = `-- name: CountSakes :one
SELECT COUNT(*) AS total
FROM sakes s
WHERE
    ($1::INTEGER IS NULL OR s.type_id = $1)
    AND ($2::INTEGER IS NULL OR s.brewery_id = $2)
`

type CountSakesParams struct {
	TypeID    *int32 `db:"type_id" json:"type_id"`
	BreweryID *int32 `db:"brewery_id" json:"brewery_id"`
}

func (q *Queries) CountSakes(ctx context.Context, arg CountSakesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSakes, arg.TypeID, arg.BreweryID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getBrewery = `-- name: GetBrewery :one
SELECT id, name, origin_country, origin_region, position, created_at, updated_at
FROM breweries
WHERE id = $1
`

func (q *Queries) GetBrewery(ctx context.Context, id int32) (Brewery, error) {
	row := q.db.QueryRow(ctx, getBrewery, id)
	var i Brewery
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OriginCountry,
		&i.OriginRegion,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDrinkStylesBySakeID = `-- name: GetDrinkStylesBySakeID :many
SELECT
    ds.id,
    ds.name,
    ds.description,
    ds.created_at,
    ds.updated_at
FROM drink_styles ds
INNER JOIN sake_drink_styles sds ON ds.id = sds.drink_style_id
WHERE sds.sake_id = $1
ORDER BY ds.id
`

func (q *Queries) GetDrinkStylesBySakeID(ctx context.Context, sakeID int32) ([]DrinkStyle, error) {
	rows, err := q.db.Query(ctx, getDrinkStylesBySakeID, sakeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DrinkStyle
	for rows.Next() {
		var i DrinkStyle
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSakeType = `-- name: GetSakeType :one
SELECT id, name, created_at, updated_at
FROM sake_types
WHERE id = $1
`

func (q *Queries) GetSakeType(ctx context.Context, id int32) (SakeType, error) {
	row := q.db.QueryRow(ctx, getSakeType, id)
	var i SakeType
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSakes = `-- name: ListSakes :many
SELECT
    s.id,
    s.type_id,
    s.brewery_id,
    s.name,
    s.abv,
    s.taste_notes,
    s.memo,
    s.created_at,
    s.updated_at
FROM sakes s
WHERE
    ($3::INTEGER IS NULL OR s.type_id = $3)
    AND ($4::INTEGER IS NULL OR s.brewery_id = $4)
ORDER BY s.created_at DESC
LIMIT $1 OFFSET $2
`

type ListSakesParams struct {
	Limit     int32  `db:"limit" json:"limit"`
	Offset    int32  `db:"offset" json:"offset"`
	TypeID    *int32 `db:"type_id" json:"type_id"`
	BreweryID *int32 `db:"brewery_id" json:"brewery_id"`
}

func (q *Queries) ListSakes(ctx context.Context, arg ListSakesParams) ([]Sake, error) {
	rows, err := q.db.Query(ctx, listSakes,
		arg.Limit,
		arg.Offset,
		arg.TypeID,
		arg.BreweryID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sake
	for rows.Next() {
		var i Sake
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.BreweryID,
			&i.Name,
			&i.Abv,
			&i.TasteNotes,
			&i.Memo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
